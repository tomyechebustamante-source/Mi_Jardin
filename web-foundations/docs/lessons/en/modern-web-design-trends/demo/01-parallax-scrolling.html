<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Module 1: Parallax Scrolling Demo</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			body {
				font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
				line-height: 1.6;
			}

			.header {
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				color: white;
				padding: 2rem;
				text-align: center;
			}

			/* Parallax background with fixed attachment */
			.parallax-bg {
				background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)),
					url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 600"><rect fill="%23667eea" width="1200" height="600"/><circle cx="200" cy="150" r="80" fill="%23764ba2" opacity="0.3"/><circle cx="800" cy="400" r="120" fill="%23764ba2" opacity="0.2"/><circle cx="1000" cy="200" r="60" fill="%23764ba2" opacity="0.4"/></svg>');
				min-height: 400px;
				background-attachment: fixed;
				background-position: center;
				background-repeat: no-repeat;
				background-size: cover;
				display: flex;
				align-items: center;
				justify-content: center;
				color: white;
				font-size: 2rem;
				font-weight: bold;
				text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
			}

			/* Regular scrolling content (foreground) */
			.content {
				background: white;
				padding: 3rem 2rem;
				max-width: 800px;
				margin: 0 auto;
			}

			.content h2 {
				color: #667eea;
				margin-bottom: 1rem;
			}

			.content p {
				margin-bottom: 1rem;
				color: #333;
			}

			.comparison {
				margin-top: 2rem;
				padding: 1.5rem;
				background: #f8f9fa;
				border-left: 4px solid #667eea;
				border-radius: 4px;
			}

			.code-box {
				background: #2d3748;
				color: #a0aec0;
				padding: 1.5rem;
				border-radius: 8px;
				margin: 1rem 0;
				overflow-x: auto;
			}

			.code-box code {
				font-family: 'Courier New', monospace;
				font-size: 0.9rem;
			}

			.reflection {
				background: #fef3c7;
				padding: 1.5rem;
				border-radius: 8px;
				margin: 2rem 0;
				border-left: 4px solid #f59e0b;
			}

			.reflection strong {
				color: #92400e;
			}

			/* Non-parallax comparison section */
			.normal-bg {
				background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)),
					url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 600"><rect fill="%2310b981" width="1200" height="600"/><circle cx="300" cy="250" r="100" fill="%23059669" opacity="0.3"/><circle cx="900" cy="350" r="80" fill="%23059669" opacity="0.4"/></svg>');
				min-height: 400px;
				background-attachment: scroll;
				background-position: center;
				background-repeat: no-repeat;
				background-size: cover;
				display: flex;
				align-items: center;
				justify-content: center;
				color: white;
				font-size: 2rem;
				font-weight: bold;
				text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
			}

			/* JavaScript-based Parallax Section */
			.parallax-js-section {
				position: relative;
				height: 600px;
				overflow: hidden;
				background: linear-gradient(to bottom, #0f2027, #203a43, #2c5364);
			}

			.parallax-layer {
				position: absolute;
				width: 100%;
				height: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
				will-change: transform;
			}

			.layer-back {
				font-size: 8rem;
				opacity: 0.2;
				color: #667eea;
				font-weight: bold;
			}

			.layer-middle {
				font-size: 4rem;
				opacity: 0.5;
				color: #f59e0b;
				font-weight: bold;
			}

			.layer-front {
				font-size: 2rem;
				color: white;
				font-weight: bold;
				text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.7);
			}

			/* Image layers for parallax */
			.parallax-image-section {
				position: relative;
				height: 500px;
				overflow: hidden;
				background: #1a202c;
			}

			.image-layer {
				position: absolute;
				width: 100%;
				height: 120%;
				background-size: cover;
				background-position: center;
				will-change: transform;
			}

			.image-layer-1 {
				background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 800"><rect fill="%231a202c" width="1200" height="800"/><circle cx="200" cy="600" r="150" fill="%23667eea" opacity="0.1"/><circle cx="1000" cy="200" r="200" fill="%23764ba2" opacity="0.1"/></svg>');
				z-index: 1;
			}

			.image-layer-2 {
				background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 800"><circle cx="600" cy="400" r="100" fill="%23f59e0b" opacity="0.3"/><circle cx="300" cy="200" r="80" fill="%2310b981" opacity="0.3"/><circle cx="900" cy="600" r="120" fill="%23ef4444" opacity="0.3"/></svg>');
				z-index: 2;
			}

			.image-layer-3 {
				background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 800"><text x="600" y="400" text-anchor="middle" font-size="80" fill="white" opacity="0.8" font-family="Arial">‚õ∞Ô∏è Mountains</text></svg>');
				z-index: 3;
			}

			.speed-indicator {
				position: absolute;
				bottom: 20px;
				left: 50%;
				transform: translateX(-50%);
				background: rgba(0, 0, 0, 0.7);
				color: white;
				padding: 1rem 2rem;
				border-radius: 8px;
				z-index: 10;
				font-size: 0.9rem;
			}

			@media (max-width: 768px) {
				.parallax-bg,
				.normal-bg {
					background-attachment: scroll;
					min-height: 300px;
					font-size: 1.5rem;
				}

				.content {
					padding: 2rem 1rem;
				}

				.parallax-js-section,
				.parallax-image-section {
					height: 400px;
				}

				.layer-back {
					font-size: 4rem;
				}
				.layer-middle {
					font-size: 2rem;
				}
				.layer-front {
					font-size: 1.5rem;
				}
			}
		</style>
	</head>
	<body>
		<div class="header">
			<h1>üé¨ Module 1: Parallax Scrolling</h1>
			<p>Adding Depth Like a Movie</p>
		</div>

		<div class="parallax-bg">
			<div>Parallax Background (Fixed)</div>
		</div>

		<div class="content">
			<h2>What Is Parallax Scrolling?</h2>
			<p>
				Parallax scrolling makes backgrounds move slower than foreground content as you scroll. It's like looking out a car
				window: trees (background) move slower than the road (foreground). This adds depth and makes sites feel dynamic.
			</p>

			<h2>Technique 1: CSS Fixed Background</h2>
			<p>
				The key CSS property is
				<code>background-attachment: fixed</code>
				. This keeps the background image stationary while the content scrolls over it.
			</p>

			<div class="code-box">
				<code>
					.parallax-bg {
					<br />
					&nbsp;&nbsp;background-image: url('image.jpg');
					<br />
					&nbsp;&nbsp;min-height: 400px;
					<br />
					&nbsp;&nbsp;background-attachment: fixed;
					<br />
					&nbsp;&nbsp;background-position: center;
					<br />
					&nbsp;&nbsp;background-size: cover;
					<br />
					}
				</code>
			</div>

			<div class="comparison">
				<h3>Why Use It?</h3>
				<ul>
					<li>
						<strong>Engagement:</strong>
						Makes sites more engaging (users scroll longer)
					</li>
					<li>
						<strong>Storytelling:</strong>
						Helps tell a story visually through layers
					</li>
					<li>
						<strong>Depth:</strong>
						Creates a sense of 3D space on a 2D screen
					</li>
				</ul>
				<h3>‚ö†Ô∏è Cautions:</h3>
				<ul>
					<li>Can cause motion sickness in some users</li>
					<li>May impact performance on older devices</li>
					<li>Doesn't work well on mobile (iOS Safari doesn't support it)</li>
					<li>Use sparingly for best effect</li>
				</ul>
			</div>

			<div class="reflection">
				<strong>Atelier Reflection:</strong>
				Does the parallax effect make this page feel more "alive"? Why or why not? Does it enhance your understanding of the
				content, or is it purely decorative? Consider the balance between visual interest and accessibility.
			</div>
		</div>

		<div class="normal-bg">
			<div>Normal Scrolling Background</div>
		</div>

		<div class="content">
			<h2>Comparison: Normal Scrolling</h2>
			<p>
				The section above uses
				<code>background-attachment: scroll</code>
				(the default). Notice how it scrolls with the content instead of staying fixed. This is the traditional approach.
			</p>

			<div class="comparison">
				<h3>Key Differences:</h3>
				<ul>
					<li>
						<strong>Parallax (fixed):</strong>
						Background stays in place, content moves over it
					</li>
					<li>
						<strong>Normal (scroll):</strong>
						Background and content move together at the same speed
					</li>
				</ul>
				<p>
					<strong>Tip:</strong>
					Scroll up and down this page multiple times to really feel the difference between the purple (parallax) and green
					(normal) sections!
				</p>
			</div>

			<h2>Mobile Considerations</h2>
			<p>
				On mobile devices,
				<code>background-attachment: fixed</code>
				often doesn't work due to browser limitations. The CSS in this demo automatically switches to regular scrolling on
				smaller screens to ensure a good experience for all users.
			</p>

			<div class="reflection">
				<strong>Critical Design Question:</strong>
				Is the parallax effect truly enhancing the user experience, or could it be a barrier? Consider users with vestibular
				disorders who may experience discomfort with motion effects. How might we offer alternatives or respect the
				<code>prefers-reduced-motion</code>
				media query?
			</div>
		</div>

		<!-- JavaScript-based Parallax with Multiple Layers -->
		<div class="parallax-js-section" id="js-parallax">
			<div class="parallax-layer layer-back" data-speed="0.2">üåå</div>
			<div class="parallax-layer layer-middle" data-speed="0.5">‚òÅÔ∏è</div>
			<div class="parallax-layer layer-front" data-speed="0.8">JavaScript Parallax</div>
			<div class="speed-indicator">Scroll to see 3 layers moving at different speeds</div>
		</div>

		<div class="content">
			<h2>Technique 2: JavaScript Parallax with Multiple Layers</h2>
			<p>
				The section above uses
				<strong>
					JavaScript with
					<code>transform: translateY()</code>
				</strong>
				to move three separate layers at different speeds. This creates a more sophisticated depth effect than pure CSS.
			</p>

			<div class="comparison" style="background: #e0f2fe; border-left-color: #0284c7;">
				<h3>Understanding the 3-Layer System</h3>
				<p>Each layer has a <code>data-speed</code> attribute:</p>
				<ul>
					<li><strong>Back layer (üåå):</strong> <code>data-speed="0.2"</code> - Moves very slowly (distant background)</li>
					<li><strong>Middle layer (‚òÅÔ∏è):</strong> <code>data-speed="0.5"</code> - Moves at medium speed</li>
					<li><strong>Front layer (text):</strong> <code>data-speed="0.8"</code> - Moves fastest (closest to viewer)</li>
				</ul>
			</div>

			<h3>Step 1: HTML Structure with data-speed</h3>
			<div class="code-box">
				<code>
					&lt;div class="parallax-js-section"&gt;
					<br />
					&nbsp;&nbsp;&lt;!-- Each layer moves at different speed --&gt;
					<br />
					&nbsp;&nbsp;&lt;div class="parallax-layer layer-back" data-speed="0.2"&gt;üåå&lt;/div&gt;
					<br />
					&nbsp;&nbsp;&lt;div class="parallax-layer layer-middle" data-speed="0.5"&gt;‚òÅÔ∏è&lt;/div&gt;
					<br />
					&nbsp;&nbsp;&lt;div class="parallax-layer layer-front" data-speed="0.8"&gt;Text&lt;/div&gt;
					<br />
					&lt;/div&gt;
				</code>
			</div>

			<h3>Step 2: JavaScript reads data-speed and applies transform</h3>
			<div class="code-box">
				<code>
					// 1. Select all layers
					<br />
					const parallaxLayers = document.querySelectorAll('.parallax-layer');
					<br />
					<br />
					// 2. On scroll, update each layer's position
					<br />
					function updateParallax() {
					<br />
					&nbsp;&nbsp;parallaxLayers.forEach((layer) => {
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;// Read the speed value from HTML attribute
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;const speed = parseFloat(layer.dataset.speed);
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;// Calculate how much to move this layer
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;const scrolled = window.pageYOffset;
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;const yPos = scrolled * speed * 0.5;
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;// Apply the transform
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;layer.style.transform = `translateY(${yPos}px)`;
					<br />
					&nbsp;&nbsp;});
					<br />
					}
					<br />
					<br />
					// 3. Listen to scroll events efficiently
					<br />
					window.addEventListener('scroll', () => {
					<br />
					&nbsp;&nbsp;requestAnimationFrame(updateParallax);
					<br />
					}, { passive: true });
				</code>
			</div>

			<div class="comparison">
				<h3>Advantages of JavaScript Parallax:</h3>
				<ul>
					<li>
						<strong>Precise Control:</strong>
						You can control exactly how fast each layer moves
					</li>
					<li>
						<strong>Multiple Elements:</strong>
						Move any HTML element, not just backgrounds
					</li>
					<li>
						<strong>Works on Mobile:</strong>
						Unlike
						<code>background-attachment: fixed</code>
					</li>
					<li>
						<strong>Complex Animations:</strong>
						Combine with opacity, scale, rotation, etc.
					</li>
				</ul>
				<h3>‚ö†Ô∏è Considerations:</h3>
				<ul>
					<li>Requires JavaScript (fallback if JS is disabled)</li>
					<li>
						Use
						<code>requestAnimationFrame</code>
						for better performance
					</li>
					<li>
						Respect
						<code>prefers-reduced-motion</code>
					</li>
				</ul>
			</div>
		</div>

		<div class="content" style="background: #fef3c7;">
			<h2>‚ôø Accessibility: Respecting User Preferences</h2>
			
			<div class="comparison" style="background: #fef3c7; border-left-color: #f59e0b;">
				<h3>‚ö†Ô∏è Important: Motion Sensitivity</h3>
				<p>
					Parallax effects can cause <strong>motion sickness, dizziness, or vestibular disorders</strong> for some users. 
					It's essential to respect the <code>prefers-reduced-motion</code> media query.
				</p>
			</div>

			<h3>What is prefers-reduced-motion?</h3>
			<p>
				<code>prefers-reduced-motion</code> is a CSS media query that detects if a user has requested reduced motion 
				in their operating system settings. Users can enable this in:
			</p>
			<ul>
				<li><strong>macOS:</strong> System Preferences ‚Üí Accessibility ‚Üí Display ‚Üí Reduce motion</li>
				<li><strong>Windows:</strong> Settings ‚Üí Ease of Access ‚Üí Display ‚Üí Show animations</li>
				<li><strong>iOS:</strong> Settings ‚Üí Accessibility ‚Üí Motion ‚Üí Reduce Motion</li>
				<li><strong>Android:</strong> Settings ‚Üí Accessibility ‚Üí Remove animations</li>
			</ul>

			<h3>How This Demo Respects It</h3>
			<p>This demo automatically disables parallax effects when users have motion reduction enabled:</p>

			<div class="code-box">
				<code>
					// 1. Detect user's motion preference
					<br />
					const prefersReducedMotion = window.matchMedia(
					<br />
					&nbsp;&nbsp;'(prefers-reduced-motion: reduce)'
					<br />
					);
					<br />
					let isReducedMotion = prefersReducedMotion.matches;
					<br />
					<br />
					// 2. Disable CSS parallax if needed
					<br />
					function handleMotionPreference() {
					<br />
					&nbsp;&nbsp;if (isReducedMotion) {
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;// Change fixed backgrounds to scroll normally
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;document.querySelectorAll('.parallax-bg').forEach((el) => {
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;el.style.backgroundAttachment = 'scroll';
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;});
					<br />
					&nbsp;&nbsp;}
					<br />
					}
					<br />
					<br />
					// 3. Don't initialize JavaScript parallax if reduced motion
					<br />
					function initParallax() {
					<br />
					&nbsp;&nbsp;if (isReducedMotion) {
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;console.log('Parallax disabled: user prefers reduced motion');
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;return; // Exit without setting up animations
					<br />
					&nbsp;&nbsp;}
					<br />
					&nbsp;&nbsp;// ... rest of parallax code
					<br />
					}
					<br />
					<br />
					// 4. Listen for preference changes during session
					<br />
					prefersReducedMotion.addEventListener('change', (e) => {
					<br />
					&nbsp;&nbsp;isReducedMotion = e.matches;
					<br />
					&nbsp;&nbsp;// Update animations accordingly
					<br />
					});
				</code>
			</div>

			<h3>Test It Yourself</h3>
			<ol>
				<li>Open your browser's DevTools (F12)</li>
				<li>Go to the Console tab and type: <code>window.matchMedia('(prefers-reduced-motion: reduce)').matches</code></li>
				<li>It returns <code>true</code> if reduce motion is enabled, <code>false</code> otherwise</li>
				<li>Enable "Reduce motion" in your OS settings and refresh this page</li>
				<li>Notice how all parallax effects are disabled!</li>
			</ol>

			<div class="comparison" style="background: #e0f2fe; border-left-color: #0284c7;">
				<h3>üí° Best Practices for Accessibility</h3>
				<ul>
					<li><strong>Always respect prefers-reduced-motion</strong> - It's a user request, not a suggestion</li>
					<li><strong>Provide fallbacks:</strong> Ensure content is accessible without motion</li>
					<li><strong>Don't just reduce:</strong> Disable motion entirely when requested</li>
					<li><strong>Test thoroughly:</strong> Check with motion reduction enabled</li>
					<li><strong>Semantic HTML:</strong> Use proper structure that works regardless of effects</li>
				</ul>
			</div>
		</div>

		<!-- Image-based Parallax Layers -->
		<div class="parallax-image-section" id="image-parallax">
			<div class="image-layer image-layer-1" data-speed="0.3"></div>
			<div class="image-layer image-layer-2" data-speed="0.6"></div>
			<div class="image-layer image-layer-3" data-speed="0.9"></div>
			<div class="speed-indicator">3 image layers ‚Ä¢ Speeds: slow (0.3) ‚Üí medium (0.6) ‚Üí fast (0.9)</div>
		</div>

		<div class="content">
			<h2>Technique 3: Multi-Layer Images</h2>
			<p>The section above combines multiple background images moving at different speeds to create a 3D depth effect.</p>

			<div class="comparison">
				<h3>üìä Comparison of All 3 Techniques:</h3>
				<table style="width: 100%; border-collapse: collapse; margin-top: 1rem">
					<tr style="background: #f8f9fa; font-weight: bold">
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">Technique</td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">Implementation</td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">Mobile Support</td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">Complexity</td>
					</tr>
					<tr>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6"><strong>CSS Fixed</strong></td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">background-attachment: fixed</td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">‚ùå Limited</td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">‚≠ê Very simple</td>
					</tr>
					<tr>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6"><strong>JS Transform</strong></td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">transform: translateY()</td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">‚úÖ Works</td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">‚≠ê‚≠ê Medium</td>
					</tr>
					<tr>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6"><strong>Multi-layer</strong></td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">Multiple elements + JS</td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">‚úÖ Works</td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">‚≠ê‚≠ê‚≠ê Advanced</td>
					</tr>
				</table>
			</div>

			<div class="reflection">
				<strong>Final Reflection:</strong>
				Which technique do you prefer? CSS is perfect for simple sites. JavaScript offers full control but requires more
				code. Multi-layer creates the most impressive effects but may impact performance.
				<strong>The best choice depends on your specific project.</strong>
			</div>
		</div>

		<script>
			// Check for reduced motion preference
			const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');
			let isReducedMotion = prefersReducedMotion.matches;

			// Handle CSS-based parallax
			function handleMotionPreference() {
				const parallaxElements = document.querySelectorAll('.parallax-bg');

				if (isReducedMotion) {
					// User prefers reduced motion - disable parallax
					parallaxElements.forEach((el) => {
						el.style.backgroundAttachment = 'scroll';
					});
					console.log('Parallax disabled: user prefers reduced motion');
				}
			}

			// JavaScript-based Parallax Implementation
			function initParallax() {
				if (isReducedMotion) {
					console.log('JS Parallax disabled: respecting reduced motion preference');
					return;
				}

				const parallaxLayers = document.querySelectorAll('.parallax-layer, .image-layer');
				let ticking = false;

				function updateParallax() {
					parallaxLayers.forEach((layer) => {
						const speed = parseFloat(layer.dataset.speed) || 0.5;
						const section = layer.parentElement;
						const rect = section.getBoundingClientRect();

						// Only animate when section is in viewport
						if (rect.top < window.innerHeight && rect.bottom > 0) {
							// Calculate scroll position relative to section's position
							const sectionTop = section.offsetTop;
							const scrolled = window.pageYOffset;
							const offset = scrolled - sectionTop;
							const yPos = offset * speed * 0.5; // Multiply by 0.5 to reduce movement

							// Use transform for better performance
							layer.style.transform = `translateY(${yPos}px)`;
						}
					});

					ticking = false;
				}

				function requestTick() {
					if (!ticking) {
						requestAnimationFrame(updateParallax);
						ticking = true;
					}
				}

				// Throttle scroll events using requestAnimationFrame
				window.addEventListener('scroll', requestTick, { passive: true });

				// Initial update
				updateParallax();
			}

			// Initialize everything
			handleMotionPreference();
			initParallax();

			// Listen for motion preference changes
			prefersReducedMotion.addEventListener('change', (e) => {
				isReducedMotion = e.matches;
				handleMotionPreference();

				if (isReducedMotion) {
					// Reset all transforms
					document.querySelectorAll('.parallax-layer, .image-layer').forEach((layer) => {
						layer.style.transform = 'translateY(0)';
					});
				} else {
					initParallax();
				}
			});

			// Log performance info for learning
			console.log('üé¨ Parallax Demo Loaded');
			console.log('üìä Layers detected:', document.querySelectorAll('.parallax-layer, .image-layer').length);
			console.log('‚ôø Reduced motion:', isReducedMotion ? 'ENABLED' : 'DISABLED');
		</script>
	</body>
</html>
