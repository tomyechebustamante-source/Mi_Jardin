<!DOCTYPE html>
<html lang="es">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>M√≥dulo 1: Demo de Parallax Scrolling</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			body {
				font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
				line-height: 1.6;
			}

			.header {
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				color: white;
				padding: 2rem;
				text-align: center;
			}

			/* Parallax background with fixed attachment */
			.parallax-bg {
				background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)),
					url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 600"><rect fill="%23667eea" width="1200" height="600"/><circle cx="200" cy="150" r="80" fill="%23764ba2" opacity="0.3"/><circle cx="800" cy="400" r="120" fill="%23764ba2" opacity="0.2"/><circle cx="1000" cy="200" r="60" fill="%23764ba2" opacity="0.4"/></svg>');
				min-height: 400px;
				background-attachment: fixed;
				background-position: center;
				background-repeat: no-repeat;
				background-size: cover;
				display: flex;
				align-items: center;
				justify-content: center;
				color: white;
				font-size: 2rem;
				font-weight: bold;
				text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
			}

			/* Regular scrolling content (foreground) */
			.content {
				background: white;
				padding: 3rem 2rem;
				max-width: 800px;
				margin: 0 auto;
			}

			.content h2 {
				color: #667eea;
				margin-bottom: 1rem;
			}

			.content p {
				margin-bottom: 1rem;
				color: #333;
			}

			.comparison {
				margin-top: 2rem;
				padding: 1.5rem;
				background: #f8f9fa;
				border-left: 4px solid #667eea;
				border-radius: 4px;
			}

			.code-box {
				background: #2d3748;
				color: #a0aec0;
				padding: 1.5rem;
				border-radius: 8px;
				margin: 1rem 0;
				overflow-x: auto;
			}

			.code-box code {
				font-family: 'Courier New', monospace;
				font-size: 0.9rem;
			}

			.reflection {
				background: #fef3c7;
				padding: 1.5rem;
				border-radius: 8px;
				margin: 2rem 0;
				border-left: 4px solid #f59e0b;
			}

			.reflection strong {
				color: #92400e;
			}

			/* Non-parallax comparison section */
			.normal-bg {
				background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)),
					url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 600"><rect fill="%2310b981" width="1200" height="600"/><circle cx="300" cy="250" r="100" fill="%23059669" opacity="0.3"/><circle cx="900" cy="350" r="80" fill="%23059669" opacity="0.4"/></svg>');
				min-height: 400px;
				background-attachment: scroll;
				background-position: center;
				background-repeat: no-repeat;
				background-size: cover;
				display: flex;
				align-items: center;
				justify-content: center;
				color: white;
				font-size: 2rem;
				font-weight: bold;
				text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
			}

			/* JavaScript-based Parallax Section */
			.parallax-js-section {
				position: relative;
				height: 600px;
				overflow: hidden;
				background: linear-gradient(to bottom, #0f2027, #203a43, #2c5364);
			}

			.parallax-layer {
				position: absolute;
				width: 100%;
				height: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
				will-change: transform;
			}

			.layer-back {
				font-size: 8rem;
				opacity: 0.2;
				color: #667eea;
				font-weight: bold;
			}

			.layer-middle {
				font-size: 4rem;
				opacity: 0.5;
				color: #f59e0b;
				font-weight: bold;
			}

			.layer-front {
				font-size: 2rem;
				color: white;
				font-weight: bold;
				text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.7);
			}

			/* Image layers for parallax */
			.parallax-image-section {
				position: relative;
				height: 500px;
				overflow: hidden;
				background: #1a202c;
			}

			.image-layer {
				position: absolute;
				width: 100%;
				height: 120%;
				background-size: cover;
				background-position: center;
				will-change: transform;
			}

			.image-layer-1 {
				background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 800"><rect fill="%231a202c" width="1200" height="800"/><circle cx="200" cy="600" r="150" fill="%23667eea" opacity="0.1"/><circle cx="1000" cy="200" r="200" fill="%23764ba2" opacity="0.1"/></svg>');
				z-index: 1;
			}

			.image-layer-2 {
				background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 800"><circle cx="600" cy="400" r="100" fill="%23f59e0b" opacity="0.3"/><circle cx="300" cy="200" r="80" fill="%2310b981" opacity="0.3"/><circle cx="900" cy="600" r="120" fill="%23ef4444" opacity="0.3"/></svg>');
				z-index: 2;
			}

			.image-layer-3 {
				background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 800"><text x="600" y="400" text-anchor="middle" font-size="80" fill="white" opacity="0.8" font-family="Arial">‚õ∞Ô∏è Monta√±as</text></svg>');
				z-index: 3;
			}

			.speed-indicator {
				position: absolute;
				bottom: 20px;
				left: 50%;
				transform: translateX(-50%);
				background: rgba(0, 0, 0, 0.7);
				color: white;
				padding: 1rem 2rem;
				border-radius: 8px;
				z-index: 10;
				font-size: 0.9rem;
			}

			@media (max-width: 768px) {
				.parallax-bg,
				.normal-bg {
					background-attachment: scroll;
					min-height: 300px;
					font-size: 1.5rem;
				}

				.content {
					padding: 2rem 1rem;
				}

				.parallax-js-section,
				.parallax-image-section {
					height: 400px;
				}

				.layer-back {
					font-size: 4rem;
				}
				.layer-middle {
					font-size: 2rem;
				}
				.layer-front {
					font-size: 1.5rem;
				}
			}
		</style>
	</head>
	<body>
		<div class="header">
			<h1>üé¨ M√≥dulo 1: Parallax Scrolling</h1>
			<p>A√±adiendo Profundidad Como una Pel√≠cula</p>
		</div>

		<div class="parallax-bg">
			<div>Fondo Parallax (Fijo)</div>
		</div>

		<div class="content">
			<h2>¬øQu√© es el Parallax Scrolling?</h2>
			<p>
				El parallax scrolling hace que los fondos se muevan m√°s lento que el contenido en primer plano mientras desplazas. Es como mirar por la ventana de un auto: los √°rboles (fondo) se mueven m√°s lento que la carretera (primer plano). Esto a√±ade profundidad y hace que los sitios se sientan din√°micos.
			</p>

			<h2>T√©cnica 1: Fondo Fijo CSS</h2>
			<p>
				La propiedad CSS clave es
				<code>background-attachment: fixed</code>
				. Esto mantiene la imagen de fondo estacionaria mientras el contenido se desplaza sobre ella.
			</p>

			<div class="code-box">
				<code>
					.parallax-bg {
					<br />
					&nbsp;&nbsp;background-image: url('image.jpg');
					<br />
					&nbsp;&nbsp;min-height: 400px;
					<br />
					&nbsp;&nbsp;background-attachment: fixed;
					<br />
					&nbsp;&nbsp;background-position: center;
					<br />
					&nbsp;&nbsp;background-size: cover;
					<br />
					}
				</code>
			</div>

			<div class="comparison">
				<h3>¬øPor Qu√© Usarlo?</h3>
				<ul>
					<li>
						<strong>Compromiso:</strong>
						Hace que los sitios sean m√°s atractivos (los usuarios se desplazan m√°s tiempo)
					</li>
					<li>
						<strong>Narraci√≥n:</strong>
						Ayuda a contar una historia visualmente a trav√©s de capas
					</li>
					<li>
						<strong>Profundidad:</strong>
						Crea una sensaci√≥n de espacio 3D en una pantalla 2D
					</li>
				</ul>
				<h3>‚ö†Ô∏è Precauciones:</h3>
				<ul>
					<li>Puede causar mareos en algunos usuarios</li>
					<li>Puede afectar el rendimiento en dispositivos antiguos</li>
					<li>No funciona bien en m√≥viles (iOS Safari no lo soporta)</li>
					<li>√ösalo con moderaci√≥n para obtener el mejor efecto</li>
				</ul>
			</div>

			<div class="reflection">
				<strong>Reflexi√≥n Atelier:</strong>
				¬øEl efecto parallax hace que esta p√°gina se sienta m√°s "viva"? ¬øPor qu√© s√≠ o por qu√© no? ¬øMejora tu comprensi√≥n del
				contenido, o es puramente decorativo? Considera el equilibrio entre el inter√©s visual y la accesibilidad.
			</div>
		</div>

		<div class="normal-bg">
			<div>Fondo con Scroll Normal</div>
		</div>

		<div class="content">
			<h2>Comparaci√≥n: Scroll Normal</h2>
			<p>
				La secci√≥n anterior usa
				<code>background-attachment: scroll</code>
				(el valor por defecto). Nota c√≥mo se desplaza con el contenido en lugar de permanecer fijo. Este es el enfoque tradicional.
			</p>

			<div class="comparison">
				<h3>Diferencias Clave:</h3>
				<ul>
					<li>
						<strong>Parallax (fijo):</strong>
						El fondo permanece en su lugar, el contenido se mueve sobre √©l
					</li>
					<li>
						<strong>Normal (scroll):</strong>
						El fondo y el contenido se mueven juntos a la misma velocidad
					</li>
				</ul>
				<p>
					<strong>Consejo:</strong>
					¬°Despl√°zate hacia arriba y hacia abajo en esta p√°gina varias veces para realmente sentir la diferencia entre las secciones p√∫rpura (parallax) y verde
					(normal)!
				</p>
			</div>

			<h2>Consideraciones para M√≥viles</h2>
			<p>
				En dispositivos m√≥viles,
				<code>background-attachment: fixed</code>
				a menudo no funciona debido a limitaciones del navegador. El CSS en este demo cambia autom√°ticamente a scroll regular en
				pantallas m√°s peque√±as para asegurar una buena experiencia para todos los usuarios.
			</p>

			<div class="reflection">
				<strong>Pregunta Cr√≠tica de Dise√±o:</strong>
				¬øEl efecto parallax realmente mejora la experiencia del usuario, o podr√≠a ser una barrera? Considera a los usuarios con trastornos
				vestibulares que pueden experimentar incomodidad con los efectos de movimiento. ¬øC√≥mo podr√≠amos ofrecer alternativas o respetar la
				media query
				<code>prefers-reduced-motion</code>
				?
			</div>
		</div>

		<!-- JavaScript-based Parallax with Multiple Layers -->
		<div class="parallax-js-section" id="js-parallax">
			<div class="parallax-layer layer-back" data-speed="0.2">üåå</div>
			<div class="parallax-layer layer-middle" data-speed="0.5">‚òÅÔ∏è</div>
			<div class="parallax-layer layer-front" data-speed="0.8">JavaScript Parallax</div>
			<div class="speed-indicator">Scroll para ver 3 capas movi√©ndose a diferentes velocidades</div>
		</div>

		<div class="content">
			<h2>T√©cnica 2: Parallax con JavaScript y M√∫ltiples Capas</h2>
			<p>
				La secci√≥n anterior usa
				<strong>
					JavaScript con
					<code>transform: translateY()</code>
				</strong>
				para mover tres capas separadas a diferentes velocidades. Esto crea un efecto de profundidad m√°s sofisticado que el CSS puro.
			</p>

			<div class="comparison" style="background: #e0f2fe; border-left-color: #0284c7;">
				<h3>Entendiendo el Sistema de 3 Capas</h3>
				<p>Cada capa tiene un atributo <code>data-speed</code>:</p>
				<ul>
					<li><strong>Capa trasera (üåå):</strong> <code>data-speed="0.2"</code> - Se mueve muy lentamente (fondo distante)</li>
					<li><strong>Capa media (‚òÅÔ∏è):</strong> <code>data-speed="0.5"</code> - Se mueve a velocidad media</li>
					<li><strong>Capa frontal (texto):</strong> <code>data-speed="0.8"</code> - Se mueve m√°s r√°pido (m√°s cerca del espectador)</li>
				</ul>
			</div>

			<h3>Paso 1: Estructura HTML con data-speed</h3>
			<div class="code-box">
				<code>
					&lt;div class="parallax-js-section"&gt;
					<br />
					&nbsp;&nbsp;&lt;!-- Cada capa se mueve a diferente velocidad --&gt;
					<br />
					&nbsp;&nbsp;&lt;div class="parallax-layer layer-back" data-speed="0.2"&gt;üåå&lt;/div&gt;
					<br />
					&nbsp;&nbsp;&lt;div class="parallax-layer layer-middle" data-speed="0.5"&gt;‚òÅÔ∏è&lt;/div&gt;
					<br />
					&nbsp;&nbsp;&lt;div class="parallax-layer layer-front" data-speed="0.8"&gt;Texto&lt;/div&gt;
					<br />
					&lt;/div&gt;
				</code>
			</div>

			<h3>Paso 2: JavaScript lee data-speed y aplica transform</h3>
			<div class="code-box">
				<code>
					// 1. Seleccionar todas las capas
					<br />
					const parallaxLayers = document.querySelectorAll('.parallax-layer');
					<br />
					<br />
					// 2. En el scroll, actualizar la posici√≥n de cada capa
					<br />
					function updateParallax() {
					<br />
					&nbsp;&nbsp;parallaxLayers.forEach((layer) => {
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;// Leer el valor de velocidad del atributo HTML
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;const speed = parseFloat(layer.dataset.speed);
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;// Calcular cu√°nto mover esta capa
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;const scrolled = window.pageYOffset;
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;const yPos = scrolled * speed * 0.5;
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;// Aplicar la transformaci√≥n
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;layer.style.transform = `translateY(${yPos}px)`;
					<br />
					&nbsp;&nbsp;});
					<br />
					}
					<br />
					<br />
					// 3. Escuchar eventos de scroll eficientemente
					<br />
					window.addEventListener('scroll', () => {
					<br />
					&nbsp;&nbsp;requestAnimationFrame(updateParallax);
					<br />
					}, { passive: true });
				</code>
			</div>

			<div class="comparison">
				<h3>Ventajas de JavaScript Parallax:</h3>
				<ul>
					<li>
						<strong>Control Preciso:</strong>
						Puedes controlar exactamente qu√© tan r√°pido se mueve cada capa
					</li>
					<li>
						<strong>M√∫ltiples Elementos:</strong>
						Mueve cualquier elemento HTML, no solo fondos
					</li>
					<li>
						<strong>Funciona en M√≥vil:</strong>
						A diferencia de
						<code>background-attachment: fixed</code>
					</li>
					<li>
						<strong>Animaciones Complejas:</strong>
						Combina con opacidad, escala, rotaci√≥n, etc.
					</li>
				</ul>
				<h3>‚ö†Ô∏è Consideraciones:</h3>
				<ul>
					<li>Requiere JavaScript (fallback si JS est√° deshabilitado)</li>
					<li>
						Usa
						<code>requestAnimationFrame</code>
						para mejor rendimiento
					</li>
					<li>
						Respeta
						<code>prefers-reduced-motion</code>
					</li>
				</ul>
			</div>
		</div>

		<div class="content" style="background: #fef3c7;">
			<h2>‚ôø Accesibilidad: Respetando las Preferencias del Usuario</h2>
			
			<div class="comparison" style="background: #fef3c7; border-left-color: #f59e0b;">
				<h3>‚ö†Ô∏è Importante: Sensibilidad al Movimiento</h3>
				<p>
					Los efectos parallax pueden causar <strong>mareos, n√°useas o trastornos vestibulares</strong> en algunos usuarios. 
					Es esencial respetar la media query <code>prefers-reduced-motion</code>.
				</p>
			</div>

			<h3>¬øQu√© es prefers-reduced-motion?</h3>
			<p>
				<code>prefers-reduced-motion</code> es una media query de CSS que detecta si un usuario ha solicitado movimiento reducido 
				en la configuraci√≥n de su sistema operativo. Los usuarios pueden habilitar esto en:
			</p>
			<ul>
				<li><strong>macOS:</strong> Preferencias del Sistema ‚Üí Accesibilidad ‚Üí Pantalla ‚Üí Reducir movimiento</li>
				<li><strong>Windows:</strong> Configuraci√≥n ‚Üí Accesibilidad ‚Üí Pantalla ‚Üí Mostrar animaciones</li>
				<li><strong>iOS:</strong> Ajustes ‚Üí Accesibilidad ‚Üí Movimiento ‚Üí Reducir movimiento</li>
				<li><strong>Android:</strong> Configuraci√≥n ‚Üí Accesibilidad ‚Üí Eliminar animaciones</li>
			</ul>

			<h3>C√≥mo este Demo lo Respeta</h3>
			<p>Este demo desactiva autom√°ticamente los efectos parallax cuando los usuarios tienen habilitada la reducci√≥n de movimiento:</p>

			<div class="code-box">
				<code>
					// 1. Detectar la preferencia de movimiento del usuario
					<br />
					const prefersReducedMotion = window.matchMedia(
					<br />
					&nbsp;&nbsp;'(prefers-reduced-motion: reduce)'
					<br />
					);
					<br />
					let isReducedMotion = prefersReducedMotion.matches;
					<br />
					<br />
					// 2. Desactivar parallax CSS si es necesario
					<br />
					function handleMotionPreference() {
					<br />
					&nbsp;&nbsp;if (isReducedMotion) {
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;// Cambiar fondos fijos a scroll normal
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;document.querySelectorAll('.parallax-bg').forEach((el) => {
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;el.style.backgroundAttachment = 'scroll';
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;});
					<br />
					&nbsp;&nbsp;}
					<br />
					}
					<br />
					<br />
					// 3. No inicializar parallax JavaScript si hay movimiento reducido
					<br />
					function initParallax() {
					<br />
					&nbsp;&nbsp;if (isReducedMotion) {
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;console.log('Parallax desactivado: el usuario prefiere movimiento reducido');
					<br />
					&nbsp;&nbsp;&nbsp;&nbsp;return; // Salir sin configurar animaciones
					<br />
					&nbsp;&nbsp;}
					<br />
					&nbsp;&nbsp;// ... resto del c√≥digo parallax
					<br />
					}
					<br />
					<br />
					// 4. Escuchar cambios de preferencia durante la sesi√≥n
					<br />
					prefersReducedMotion.addEventListener('change', (e) => {
					<br />
					&nbsp;&nbsp;isReducedMotion = e.matches;
					<br />
					&nbsp;&nbsp;// Actualizar animaciones seg√∫n corresponda
					<br />
					});
				</code>
			</div>

			<h3>Pru√©balo T√∫ Mismo</h3>
			<ol>
				<li>Abre las DevTools del navegador (F12)</li>
				<li>Ve a la pesta√±a Console y escribe: <code>window.matchMedia('(prefers-reduced-motion: reduce)').matches</code></li>
				<li>Devuelve <code>true</code> si la reducci√≥n de movimiento est√° habilitada, <code>false</code> en caso contrario</li>
				<li>Habilita "Reducir movimiento" en la configuraci√≥n de tu sistema operativo y recarga esta p√°gina</li>
				<li>¬°Nota c√≥mo todos los efectos parallax est√°n desactivados!</li>
			</ol>

			<div class="comparison" style="background: #e0f2fe; border-left-color: #0284c7;">
				<h3>üí° Mejores Pr√°cticas para Accesibilidad</h3>
				<ul>
					<li><strong>Siempre respeta prefers-reduced-motion</strong> - Es una solicitud del usuario, no una sugerencia</li>
					<li><strong>Proporciona alternativas:</strong> Asegura que el contenido sea accesible sin movimiento</li>
					<li><strong>No solo reduzcas:</strong> Desactiva el movimiento por completo cuando se solicite</li>
					<li><strong>Prueba exhaustivamente:</strong> Verifica con la reducci√≥n de movimiento habilitada</li>
					<li><strong>HTML Sem√°ntico:</strong> Usa una estructura adecuada que funcione independientemente de los efectos</li>
				</ul>
			</div>
		</div>

		<!-- Image-based Parallax Layers -->
		<div class="parallax-image-section" id="image-parallax">
			<div class="image-layer image-layer-1" data-speed="0.3"></div>
			<div class="image-layer image-layer-2" data-speed="0.6"></div>
			<div class="image-layer image-layer-3" data-speed="0.9"></div>
			<div class="speed-indicator">3 capas de im√°genes ‚Ä¢ Velocidades: lenta (0.3) ‚Üí media (0.6) ‚Üí r√°pida (0.9)</div>
		</div>

		<div class="content">
			<h2>T√©cnica 3: Capas de Im√°genes (Multi-layer)</h2>
			<p>
				La secci√≥n anterior combina m√∫ltiples im√°genes de fondo movi√©ndose a diferentes velocidades para crear un efecto de
				profundidad 3D.
			</p>

			<div class="comparison">
				<h3>üìä Comparaci√≥n de las 3 T√©cnicas:</h3>
				<table style="width: 100%; border-collapse: collapse; margin-top: 1rem">
					<tr style="background: #f8f9fa; font-weight: bold">
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">T√©cnica</td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">Implementaci√≥n</td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">Soporte M√≥vil</td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">Complejidad</td>
					</tr>
					<tr>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6"><strong>CSS Fixed</strong></td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">background-attachment: fixed</td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">‚ùå Limitado</td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">‚≠ê Muy simple</td>
					</tr>
					<tr>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6"><strong>JS Transform</strong></td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">transform: translateY()</td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">‚úÖ Funciona</td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">‚≠ê‚≠ê Medio</td>
					</tr>
					<tr>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6"><strong>Multi-layer</strong></td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">M√∫ltiples elementos + JS</td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">‚úÖ Funciona</td>
						<td style="padding: 0.75rem; border: 1px solid #dee2e6">‚≠ê‚≠ê‚≠ê Avanzado</td>
					</tr>
				</table>
			</div>

			<div class="reflection">
				<strong>Reflexi√≥n Final:</strong>
				¬øCu√°l t√©cnica prefieres? La t√©cnica CSS es perfecta para sitios simples. JavaScript ofrece control total pero
				requiere m√°s c√≥digo. Multi-layer crea los efectos m√°s impresionantes pero puede afectar el rendimiento.
				<strong>La mejor elecci√≥n depende de tu proyecto espec√≠fico.</strong>
			</div>
		</div>

		<script>
			// Check for reduced motion preference
			const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');
			let isReducedMotion = prefersReducedMotion.matches;

			// Handle CSS-based parallax
			function handleMotionPreference() {
				const parallaxElements = document.querySelectorAll('.parallax-bg');

				if (isReducedMotion) {
					// User prefers reduced motion - disable parallax
					parallaxElements.forEach((el) => {
						el.style.backgroundAttachment = 'scroll';
					});
					console.log('Parallax disabled: user prefers reduced motion');
				}
			}

			// JavaScript-based Parallax Implementation
			function initParallax() {
				if (isReducedMotion) {
					console.log('JS Parallax disabled: respecting reduced motion preference');
					return;
				}

				const parallaxLayers = document.querySelectorAll('.parallax-layer, .image-layer');
				let ticking = false;

				function updateParallax() {
					parallaxLayers.forEach((layer) => {
						const speed = parseFloat(layer.dataset.speed) || 0.5;
						const section = layer.parentElement;
						const rect = section.getBoundingClientRect();

						// Only animate when section is in viewport
						if (rect.top < window.innerHeight && rect.bottom > 0) {
							// Calculate scroll position relative to section's position
							const sectionTop = section.offsetTop;
							const scrolled = window.pageYOffset;
							const offset = scrolled - sectionTop;
							const yPos = offset * speed * 0.5; // Multiply by 0.5 to reduce movement

							// Use transform for better performance
							layer.style.transform = `translateY(${yPos}px)`;
						}
					});

					ticking = false;
				}

				function requestTick() {
					if (!ticking) {
						requestAnimationFrame(updateParallax);
						ticking = true;
					}
				}

				// Throttle scroll events using requestAnimationFrame
				window.addEventListener('scroll', requestTick, { passive: true });

				// Initial update
				updateParallax();
			}

			// Initialize everything
			handleMotionPreference();
			initParallax();

			// Listen for motion preference changes
			prefersReducedMotion.addEventListener('change', (e) => {
				isReducedMotion = e.matches;
				handleMotionPreference();

				if (isReducedMotion) {
					// Reset all transforms
					document.querySelectorAll('.parallax-layer, .image-layer').forEach((layer) => {
						layer.style.transform = 'translateY(0)';
					});
				} else {
					initParallax();
				}
			});

			// Log performance info for learning
			console.log('üé¨ Parallax Demo Loaded');
			console.log('üìä Layers detected:', document.querySelectorAll('.parallax-layer, .image-layer').length);
			console.log('‚ôø Reduced motion:', isReducedMotion ? 'ENABLED' : 'DISABLED');
		</script>
	</body>
</html>
